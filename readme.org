#+title: scsh - scala for shell scripts

Scala can be used for scripting and scsh wants to make this more
convenient: allowing to share code between scripts and make third
party libraries available.

It produces a jar file that can be used to run scala scripts. You can
add libraries to this jar and custom utilities that are then available
in your scala scripts. There is a simple shell script provided
intended to be used in the shebang of your scala scripts:

#+begin_src scala
#!/usr/bin/env scsh
println("Hello world!")
#+end_src

It borrows ideas from [[http://www.crosson.org/2012/01/simplifying-scala-scripts-adding.html][here]] and [[https://github.com/stanislas/crsh-template][here]]. Currently this targets linux like
systems only.

* Installation

Since everybody probably has its own utilities to add, clone this repo
and build everything (using [[http://scala-sbt.org][sbt]]) with

#+begin_src shell
sbt gen-scsh
#+end_src

Then symlink the resulting shell script in =target/bin/scsh= to a
location that is in your =PATH= (or add this directory to =PATH=).

Now you can start scala scripting using the =/usr/bin/env scsh=
shebang.

The =build.sbt= file contains few keys that control the shell script
generation:

- shebang in scsh := "/bin/sh" :: The full path to a system shell.
- javaBin in scsh := "java" :: The full path to the java
     executable. The default is =java=. You can also try [[https://github.com/ninjudd/drip][drip]] that
     optimizes startup time.
- javaOptions in scsh := Seq() :: Additional java options or system
     properties that are passed to the jvm running the scripts. The
     environment variable =SCSH_OPTS= can be used to specify options
     to a specific run. It overrides those from this key.

If you call =scsh= without a script, a scala repl is started pimped
with all the libraries and utility code of this project.

When you have another utility or need more dependencies from your
scripts, simply add it to the project and run =sbt scsh= again. This
updates the script and jar file.

* Usage

Simply create a file with this first line ~#!/usr/bin/env scsh~ and
write scala code beneath. Make the file executable to run it:

#+begin_src shell
#!/usr/bin/env scsh

println("Hello " + args.toList.mkString(" "))
#+end_src

This is then a normal scala script. The arguments are bound to the
name ~args~ which is in scope. You can also create an ~object~ with a
main method. See [[http://www.scala-lang.org/documentation/getting-started.html#script_it][this short example]]. The above only makes the shell
preamble easier and could be written like this:

#+begin_src shell
#!/bin/sh
exec scala -nocompdaemon -savecompiled -usejavacp -deprecation "$0" "$@"
!#

println("Hello " + args.toList.mkString(" "))
#+end_src

If you like other options, change it in [[./src/main/scala/scsh/boot.scala][boot.scala]].

* What it contains

These are the libraries and utility code packaged up in the jar that
runs the scripts. If you find something useful is missing, please open
a pull request or an issue.

** Libraries

- [[https://github.com/pathikrit/better-files][better-files]] makes working with files in java and scala much nicer
- [[https://github.com/scala/scala-swing][scala-swing]] scala wrapper for swing
- [[https://github.com/typesafehub/scala-logging][scala-logging]] and [[http://logback.qos.ch][logback]] for logging
- [[https://github.com/scopt/scopt][scopt]] a command line parser
- [[https://github.com/xerial/sqlite-jdbc][sqlite-jdbc]] jdbc driver for [[http://www.sqlite.org][sqlite]] databases
- [[https://github.com/tototoshi/scala-csv][scala-csv]] a library for working with csv files
- [[https://github.com/typesafehub/config][typesafe's config]] a configuration library

** code

*** more file utils

The =better-files= library provides a great api for working with
files. These utilities add more helpers to the ~File~ type that are
convenient in scripts. Declare the following imports:

#+begin_src scala
import better.files._
import scsh.files._
#+end_src

Some examples follow:

#+begin_src scala
File("a.Txt").hasExtensions(Set("txt", "md")) == true
#+end_src

~hasExtensions~ checks whether the file's extension is a member of the
given set. The comparison is case-insensitive.

#+begin_src scala
File("a/b/c.txt").mapFileName("ab" + _) // -> "a/b/abc.txt"
File("a/b/c.txt").mapBaseName(_ + "de") // -> "a/b/cde.txt"
File("a/b/c.txt").mapExtension(_ => "md") // -> "a/b/c.md"
#+end_src

The ~mapXyz~ methods resolve siblings of the file based on the name or
a part thereof. The source file is not checked for existance or which
type it is and it is not changed, either (i.e. it is not renamed).

#+begin_src scala
import scsh.files.FileCheck._

File("a/b.txt").assert(missing)
File("/etc").assert(directory)
File("/etc/passwd").assert(writeable & readable)
#+end_src

The ~FileCheck~ trait is for checking certain properties of a
file. There are some defined in its companion. The ~File#assert~
method takes such a check and throws an exception, if the file doesn't
pass. This is handy to quickly verify an input or output file. The
~FileCheck~ trait additionally has an error message which is returned
with the exception.
